tasks:
  - id: architect_blueprint
    agent: architect
    description: |
      Read storage/analysis_report.json and design a comprehensive serverless
      application architecture using your knowledge base of architecture patterns.
      
      ⚠️ KNOWLEDGE-DRIVEN DESIGN:
      Before starting, consult your serverless architecture patterns knowledge base to:
      1. Identify which of the 5 patterns fits this application best
      2. Understand which services are truly needed vs nice-to-have
      3. Avoid common anti-patterns and over-engineering
      
      The 5 patterns to consider:
      - Pattern 1: Simple REST API (default for most CRUD apps)
      - Pattern 2: WebSocket Real-time
      - Pattern 3: Event-Driven Fan-Out
      - Pattern 4: Workflow Orchestration
      - Pattern 5: Hybrid Microservices
      
      ⚠️ CRITICAL: Generate blueprint in MODULAR STEPS to avoid truncation:
      
      STEP 1: Create Initial Blueprint Structure
      Write storage/blueprint.json with basic metadata and empty sections:
      {
        "metadata": {
          "application_name": "...",
          "architecture_pattern": "Pattern X: ...",
          "pattern_rationale": "Brief explanation of why this pattern was chosen"
        },
        "lambda_architecture": {},
        "data_architecture": {},
        "auth_architecture": {},
        "api_gateway": {},
        "integration_patterns": {},
        "monitoring": {},
        "dropped_functions": []
      }
      
      STEP 2: Update Lambda Architecture Section
      Read existing blueprint, update ONLY lambda_architecture section, write back:
      - Lambda functions grouped by domain (user, order, payment, etc.)
      - ⚠️ EXCLUDE functions handled by Cognito (login, register) - add to dropped_functions
      - ⚠️ EXCLUDE infrastructure scripts (init_db.py, create_tables.py)
      - Shared Lambda layers for common utilities
      - (Optional) Step Functions ONLY if complex workflows (>3 steps) detected
      
      STEP 3: Update Data Architecture Section
      Read existing blueprint, update ONLY data_architecture section, write back:
      - DynamoDB table schemas (from analysis_report.dynamodb_info)
      - Table relationships and indexes
      - (Optional) S3 buckets ONLY if file upload detected in analysis_report
      
      STEP 4: Update Auth Architecture Section
      Read existing blueprint, update ONLY auth_architecture section, write back:
      - Cognito User Pools configuration (if auth detected)
      - User pool attributes and password policies
      - Lambda triggers (PostConfirmation, PreAuthentication, etc.)
      
      STEP 5: Update API Gateway Section
      Read existing blueprint, update ONLY api_gateway section, write back:
      - API type: REST API (default) or WebSocket API (only if Pattern 2 selected)
      - CORS settings
      - Stages (dev, prod)
      - Throttling and authorization configuration
      
      STEP 6: Update Integration Patterns Section (Evidence-Based)
      Read existing blueprint, update ONLY integration_patterns section if needed:
      - Consult knowledge base for service selection rules
      - ✅ Add SQS ONLY if: background jobs, async tasks, or queues detected
      - ✅ Add SNS ONLY if: fanout to multiple subscribers (<5) detected
      - ✅ Add EventBridge ONLY if: complex event routing or >3 subscribers detected
      - ✅ Add Step Functions ONLY if: workflows with >3 dependent steps detected
      - ❌ If no clear evidence in analysis_report, keep this section minimal or empty
      - Reference knowledge base anti-patterns to avoid overuse
      
      STEP 7: Update Monitoring Section
      Read existing blueprint, update ONLY monitoring section, write back:
      - CloudWatch Log Groups configuration
      - CloudWatch Alarms for critical metrics
      
      ⚠️ IMPORTANT: Each step reads the CURRENT blueprint.json, updates ONE section, then writes back.
      This ensures the final blueprint.json is complete and not truncated.
    expected_output: |
      A complete blueprint.json file at storage/blueprint.json including all sections:
      
      - metadata:
        * application_name
        * architecture_pattern (which of the 5 patterns was selected)
        * pattern_rationale (why this pattern was chosen based on analysis)
      
      - lambda_architecture (functions, layers, optional step functions)
      - data_architecture (DynamoDB, optional S3)
      - api_gateway (REST API or WebSocket based on pattern)
      - auth_architecture (Cognito if auth detected)
      - integration_patterns (optional: only if evidence-based need detected)
      - monitoring (CloudWatch)
      - dropped_functions (list with reasons)
      
      Design Principle: Follow the selected architecture pattern from knowledge base.
      Start with Pattern 1 (Simple REST) unless analysis shows clear need for other patterns.
      Add optional services (SQS/SNS/EventBridge/Step Functions) ONLY when analysis 
      provides clear evidence. Consult knowledge base to avoid anti-patterns.

  - id: generate_complete_application
    agent: code_developer
    description: |
      Based on storage/blueprint.json, generate a COMPLETE serverless application.

      STRICT DATA SOURCE RULES:
      1. Primary Source: Use `ReadFileTool` to read the exact `source_files` defined in storage/blueprint.json. This is non-negotiable for business logic.
         ⚠️ IMPORTANT: If the source path contains a colon (e.g., "path/to/file.js:functionName"), YOU MUST SPLIT IT. Only read the file path part ("path/to/file.js").
      2. Secondary Source: Use `CodeRAGTool` to locate helper functions, models, or **similar code patterns** to understand intent and fill knowledge gaps. Always read the full content of found files with `ReadFileTool`.
      
      APPLICATION COMPONENTS:
      1. Lambda Functions:
         - Create handler.py (or .js) for each Lambda in output/lambdas/{name}/
         - Transform monolith routes to lambda_handler(event, context) functions
         - ⚠️ SKIP generation for any functions listed in "dropped_functions"
         - Convert database calls to DynamoDB boto3 operations
         - Add proper error handling, logging, and environment variable usage
         - Add requirements.txt with dependencies
      
      2. Shared Utilities:
         - Extract common code to output/shared/
         - Create Lambda layer structure in output/layers/
         - Include database clients, logging utilities, authentication helpers
      
      3. Step Functions (if needed):
         - Generate .asl.json state machine definitions in output/statemachines/
         - Include error handling, retry logic, and timeout configuration
      
      4. Event Handlers (if async processing exists):
         - SQS queue handlers for background jobs
         - SNS topic subscribers for notifications
         - EventBridge rule handlers for scheduled tasks
      
      DOCUMENTATION:
      - Create output/README.md with:
        * Project structure overview
        * Prerequisites (AWS CLI, SAM CLI, Python/Node versions)
        * Quick start: `sam build && sam deploy --guided`
        * Deployment configuration (samconfig.toml)
        * Environment variables guide
        * API endpoint documentation
        * Testing instructions with sample requests
      
      PROCESS:
      - Use ReadFileTool to read monolith source code from file mappings
      - Use CodeRAGTool to discover dependencies and utility functions
      - Use WriteFileTool to create the complete directory structure
      
      CRITICAL: Preserve all business logic exactly as in monolith.
      Generate complete, runnable files, not code snippets.
    expected_output: "A complete serverless application in output/ directory with lambdas/, shared/, statemachines/ (if applicable), and README.md, ready for SAM deployment"

  - id: generate_sam_templates
    agent: sam_engineer
    description: |
      Analyze the generated application code in output/ directory and blueprint.json,
      then generate AWS SAM templates that perfectly match the code structure.
      
      STEP 1: CODE ANALYSIS
      - Use FileListTool to scan output/lambdas/ directory
      - For each Lambda directory found:
        * Read handler.py or handler.js to extract handler function name
        * Read requirements.txt or package.json for dependencies
        * Determine runtime (python3.11, nodejs18.x, etc.)
      
      STEP 2: MAIN TEMPLATE GENERATION
      Create output/template.yaml with:
      
      1. Globals Section:
         - Default Lambda settings (timeout, memory, runtime)
         - API Gateway CORS configuration (for external API consumers)
         - Tracing configuration (X-Ray)
      
      2. Parameters:
         - Environment (dev/prod)
         - Configurable values (table names, timeouts, etc.)
      
      3. Lambda Functions:
         - AWS::Serverless::Function for EACH discovered Lambda
         - CodeUri pointing to actual code location
         - Handler matching discovered handler name
         - Environment variables referencing DynamoDB tables (!Ref)
         - IAM policies (DynamoDBCrudPolicy, etc.)
         - API Gateway events for each route
         - Event source mappings (SQS, SNS, DynamoDB Streams, EventBridge)
      
      4. DynamoDB Tables:
         - AWS::DynamoDB::Table for each table in blueprint
         - Partition key, sort key, GSI from actual code analysis
         - BillingMode: PAY_PER_REQUEST
         - DynamoDB Streams (if event-driven patterns detected)
      
      5. Step Functions (if statemachines/ exists):
         - AWS::Serverless::StateMachine
         - DefinitionUri pointing to .asl.json files
         - IAM roles for state machine execution
      
      6. Lambda Layers (if layers/ exists):
         - AWS::Serverless::LayerVersion for shared code
      
      7. Messaging & Events (if async processing exists):
         - AWS::SQS::Queue for job queues
         - AWS::SNS::Topic for pub/sub notifications
         - AWS::Events::Rule for scheduled tasks
      
      8. Storage (if file handling exists):
         - AWS::S3::Bucket for object storage
         - Bucket policies and CORS configuration
      
      9. WebSocket API (if real-time features exist):
         - AWS::ApiGatewayV2::Api for WebSocket API
         - AWS::ApiGatewayV2::Route for $connect, $disconnect, and custom routes
         - AWS::ApiGatewayV2::Integration linking routes to Lambda functions
         - AWS::ApiGatewayV2::Stage for deployment stages
      
      10. Monitoring Resources (MANDATORY):
          - AWS::Logs::LogGroup for each Lambda function (with retention policy)
          - AWS::CloudWatch::Alarm for critical metrics (Lambda errors, API 4XX/5XX, DynamoDB throttles)
      
      11. Outputs:
          - API Gateway endpoint URLs (REST/WebSocket)
          - DynamoDB table names
          - SQS queue URLs
          - SNS topic ARNs
          - S3 bucket names
          - Cognito User Pool IDs (if auth used)
      
      STEP 3: COGNITO TEMPLATE (if auth required)
      If blueprint.auth_architecture includes Cognito:
      Create output/cognito.yaml with:
      - AWS::Cognito::UserPool
      - AWS::Cognito::UserPoolClient
      - Outputs: UserPoolId, UserPoolClientId
      
      STEP 4: DEPLOYMENT CONFIGURATION
      Create output/samconfig.toml (optional but recommended) with:
      - Default deployment parameters
      - Region, stack name, capabilities
      
      STEP 5: VALIDATION
      1. Run SAMValidateTool on template.yaml
      2. Fix any cfn-lint errors (syntax, invalid properties)
      3. Validate cognito.yaml if created
      4. Verify consistency:
         - Every Lambda directory has a SAM Function resource
         - CodeUri paths are correct relative to template location
         - Handler names match actual code
         - Environment variables align with code usage
         - IAM policies cover all boto3 calls in code
      
      Repeat validation until all templates pass.
      
      CRITICAL: Templates must match the ACTUAL generated code structure,
      not just the blueprint. Analyze the real output/ directory.
      
      IMPORTANT: Always include CloudWatch Log Groups and Alarms for production readiness,
      even if not explicitly mentioned in blueprint. These are mandatory infrastructure.
    expected_output: "Validated SAM template files in output/ directory (template.yaml and optionally cognito.yaml, samconfig.toml) that exactly match the generated application code and are ready for deployment with 'sam build && sam deploy'"
